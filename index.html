<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>縱向射擊遊戲 (進階)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: sans-serif;
            color: white;
        }
        #gameCanvas {
            border: 1px solid #333;
            background-color: #0a0a1a; /* 深藍色星空背景 */
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
        /* UI 圖層 (開始/結束畫面) */
        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.75);
            visibility: hidden; /* 預設隱藏 */
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 100;
        }
        #uiLayer.visible {
            visibility: visible;
            opacity: 1;
        }
        #uiLayer h2 { font-size: 2em; margin-bottom: 10px; }
        #uiLayer p { font-size: 1.2em; margin-bottom: 20px; }
        #uiLayer button {
            padding: 15px 30px; font-size: 1.2em; cursor: pointer;
            background-color: #4CAF50; color: white; border: none; border-radius: 5px;
        }
        /* 遊戲內 UI */
        #scoreDisplay {
            position: absolute; top: 10px; left: 10px; font-size: 1.5em; z-index: 10;
        }
        #scatterShotButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 15px;
            font-size: 1em;
            background-color: #ff9800; /* 橘色 */
            color: black;
            border: none;
            border-radius: 50%; /* 圓形按鈕 */
            width: 70px; /* 固定大小 */
            height: 70px;
            cursor: pointer;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: background-color 0.2s, transform 0.1s;
        }
        #scatterShotButton:disabled {
            background-color: #9e9e9e; /* 灰色 */
            cursor: not-allowed;
        }
        #scatterShotButton:active:not(:disabled) {
            transform: scale(0.95);
        }
        #scatterAmmoDisplay {
            font-size: 0.8em;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="scoreDisplay">分數: 0</div>
    <button id="scatterShotButton" disabled>
        散彈
        <span id="scatterAmmoDisplay">(0/3)</span>
    </button>

    <div id="uiLayer">
        <h2 id="uiTitle">遊戲結束</h2>
        <p id="uiMessage"></p>
        <button id="restartButton">重新開始</button>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('uiLayer');
        const uiTitle = document.getElementById('uiTitle');
        const uiMessage = document.getElementById('uiMessage');
        const restartButton = document.getElementById('restartButton');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const scatterShotButton = document.getElementById('scatterShotButton');
        const scatterAmmoDisplay = document.getElementById('scatterAmmoDisplay');

        // --- Game Constants ---
        const PLAYER_WIDTH = 40;
        const PLAYER_HEIGHT = 50;
        const PLAYER_COLOR = 'cyan';
        const PLAYER_SHOOT_COOLDOWN = 200; // ms for normal shot
        const PLAYER_BULLET_SPEED = 8;
        const PLAYER_BULLET_COLOR = 'lime';
        const PLAYER_BULLET_WIDTH = 4;
        const PLAYER_BULLET_HEIGHT = 12;
        const SCATTER_AMMO_MAX = 3;
        const SCATTER_AMMO_REGEN_TIME = 5000; // ms (5 seconds)
        const SCATTER_BULLET_COUNT = 5; // Number of bullets in scatter shot

        const ENEMY_A_WIDTH = 35;
        const ENEMY_A_HEIGHT = 35;
        const ENEMY_A_COLOR = 'lightcoral';
        const ENEMY_A_HEALTH = 2;
        const ENEMY_A_SPEED = 2;
        const ENEMY_A_SCORE = 10;

        const ENEMY_B_WIDTH = 40;
        const ENEMY_B_HEIGHT = 40;
        const ENEMY_B_COLOR = 'yellow';
        const ENEMY_B_HEALTH = 3;
        const ENEMY_B_SPEED = 1.5;
        const ENEMY_B_SCORE = 20;
        const ENEMY_B_SHOOT_COOLDOWN = 1500; // ms
        const ENEMY_BULLET_SPEED = 4;
        const ENEMY_BULLET_COLOR = 'magenta';
        const ENEMY_BULLET_WIDTH = 6;
        const ENEMY_BULLET_HEIGHT = 6;

        const ENEMY_C_WIDTH = 100;
        const ENEMY_C_HEIGHT = 80;
        const ENEMY_C_COLOR = 'purple';
        const ENEMY_C_HEALTH_MAX = 15;
        const ENEMY_C_SPEED = 1; // Slower boss
        const ENEMY_C_SCORE = 100; // Score for hitting
        const ENEMY_C_FINAL_SCORE = 500; // Bonus for destroying
        const ENEMY_C_SHOOT_COOLDOWN = 1000; // ms
        const ENEMY_C_SCATTER_COUNT = 8;

        const ENEMY_SPAWN_RATE = 1200; // ms for A/B
        const BOSS_SCORE_THRESHOLD = 150; // Score to trigger boss

        // --- Game Variables ---
        let canvasWidth, canvasHeight;
        let player;
        let playerBullets, enemyBullets;
        let enemies;
        let score;
        let gameOver;
        let gameWon;
        let gameLoopId;
        let enemySpawnTimerId;
        let lastTime; // For delta time calculation
        let playerCanShootNormal = true;
        let playerScatterAmmo = 0;
        let scatterAmmoRegenTimer = 0; // Tracks time for regen
        let bossActive = false;
        let bossInstance = null; // Reference to the C enemy

        // --- Touch Control Variables ---
        let touchStartX = null;
        let playerStartX = null;

        // --- Utility Functions ---
        function random(min, max) { return Math.random() * (max - min) + min; }
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        function updateAmmoDisplay() {
            scatterAmmoDisplay.textContent = `(${playerScatterAmmo}/${SCATTER_AMMO_MAX})`;
            scatterShotButton.disabled = playerScatterAmmo <= 0;
        }

        // --- Game Setup Functions ---
        function resizeCanvas() {
            canvasWidth = Math.min(window.innerWidth, 500); // Max width for better layout
            canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }

        function initGame() {
            score = 0;
            gameOver = false;
            gameWon = false;
            bossActive = false;
            bossInstance = null;
            lastTime = performance.now();
            playerBullets = [];
            enemyBullets = [];
            enemies = [];
            playerScatterAmmo = SCATTER_AMMO_MAX; // Start with full ammo
            scatterAmmoRegenTimer = 0;
            playerCanShootNormal = true;

            player = {
                x: canvasWidth / 2 - PLAYER_WIDTH / 2,
                y: canvasHeight - PLAYER_HEIGHT - 30,
                width: PLAYER_WIDTH,
                height: PLAYER_HEIGHT,
                color: PLAYER_COLOR,
                lastNormalShotTime: 0,
            };

            scoreDisplay.textContent = `分數: ${score}`;
            updateAmmoDisplay();
            uiLayer.classList.remove('visible');

            // Clear any existing timers/loops
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            if (enemySpawnTimerId) clearInterval(enemySpawnTimerId);

            // Start game processes
            gameLoopId = requestAnimationFrame(gameLoop);
            startSpawningEnemies();
            playerShootNormal(); // Trigger initial normal shot check
        }

        // --- Spawning ---
        function startSpawningEnemies() {
            spawnEnemy(); // Spawn one immediately
            enemySpawnTimerId = setInterval(spawnEnemy, ENEMY_SPAWN_RATE);
        }

        function spawnEnemy() {
            if (gameOver || gameWon || bossActive) return; // Stop spawning if boss appears or game ends

            const typeChance = Math.random();
            let enemy;
            const x = random(0, canvasWidth - ENEMY_B_WIDTH); // Use wider width for positioning
            const y = -ENEMY_B_HEIGHT;

            if (typeChance < 0.65) { // 65% chance for Type A
                enemy = {
                    type: 'A', x: x, y: y,
                    width: ENEMY_A_WIDTH, height: ENEMY_A_HEIGHT, color: ENEMY_A_COLOR,
                    speed: ENEMY_A_SPEED, health: ENEMY_A_HEALTH, scoreValue: ENEMY_A_SCORE
                };
            } else { // 35% chance for Type B
                enemy = {
                    type: 'B', x: x, y: y,
                    width: ENEMY_B_WIDTH, height: ENEMY_B_HEIGHT, color: ENEMY_B_COLOR,
                    speed: ENEMY_B_SPEED, health: ENEMY_B_HEALTH, scoreValue: ENEMY_B_SCORE,
                    lastShotTime: performance.now() // For shooting cooldown
                };
            }
            enemies.push(enemy);
        }

        function spawnBoss() {
            bossActive = true;
            bossInstance = {
                type: 'C', x: canvasWidth / 2 - ENEMY_C_WIDTH / 2, y: -ENEMY_C_HEIGHT,
                width: ENEMY_C_WIDTH, height: ENEMY_C_HEIGHT, color: ENEMY_C_COLOR,
                speed: ENEMY_C_SPEED, health: ENEMY_C_HEALTH_MAX, scoreValue: ENEMY_C_SCORE,
                lastShotTime: performance.now(), targetY: 50 // Move to a certain Y position
            };
            enemies.push(bossInstance);
            clearInterval(enemySpawnTimerId); // Stop spawning A and B
        }

        // --- Shooting Functions ---
        function playerShootNormal() {
             if (gameOver || gameWon || !playerCanShootNormal) return;

             const currentTime = performance.now();
             if (currentTime - player.lastNormalShotTime >= PLAYER_SHOOT_COOLDOWN) {
                 const bulletX = player.x + player.width / 2 - PLAYER_BULLET_WIDTH / 2;
                 const bulletY = player.y;
                 playerBullets.push({
                     x: bulletX, y: bulletY, width: PLAYER_BULLET_WIDTH, height: PLAYER_BULLET_HEIGHT,
                     color: PLAYER_BULLET_COLOR, speed: PLAYER_BULLET_SPEED
                 });
                 player.lastNormalShotTime = currentTime;
             }
             // Request next check
            requestAnimationFrame(playerShootNormal);
        }

        function playerShootScatter() {
            if (gameOver || gameWon || playerScatterAmmo <= 0) return;

            playerScatterAmmo--;
            updateAmmoDisplay();

            const centerX = player.x + player.width / 2;
            const startY = player.y;
            const angles = [-0.4, -0.2, 0, 0.2, 0.4]; // Radians relative to straight up (-PI/2)

            for (let i = 0; i < SCATTER_BULLET_COUNT; i++) {
                // Simple fixed angle scatter for this example
                 const angle = Math.PI / -2 + (angles[i % angles.length] || 0) ; // Spread angles
                 const speed = PLAYER_BULLET_SPEED * 0.8; // Scatter slightly slower
                 playerBullets.push({
                     x: centerX - PLAYER_BULLET_WIDTH / 2, y: startY, width: PLAYER_BULLET_WIDTH, height: PLAYER_BULLET_HEIGHT,
                     color: 'orange', speed: speed, // Different color for scatter
                     dx: Math.cos(angle) * speed, // Velocity components
                     dy: Math.sin(angle) * speed
                 });
            }
        }

        function enemyShoot(enemy) {
            const currentTime = performance.now();
            const centerX = enemy.x + enemy.width / 2;
            const centerY = enemy.y + enemy.height / 2;

            if (enemy.type === 'B' && currentTime - enemy.lastShotTime > ENEMY_B_SHOOT_COOLDOWN) {
                // Shoot towards player
                const angle = Math.atan2(player.y - centerY, (player.x + player.width/2) - centerX);
                enemyBullets.push({
                    x: centerX - ENEMY_BULLET_WIDTH / 2, y: centerY, width: ENEMY_BULLET_WIDTH, height: ENEMY_BULLET_HEIGHT,
                    color: ENEMY_BULLET_COLOR, speed: ENEMY_BULLET_SPEED,
                    dx: Math.cos(angle) * ENEMY_BULLET_SPEED,
                    dy: Math.sin(angle) * ENEMY_BULLET_SPEED
                });
                enemy.lastShotTime = currentTime;
            }
             else if (enemy.type === 'C' && currentTime - enemy.lastShotTime > ENEMY_C_SHOOT_COOLDOWN) {
                 // Boss scatter shot
                 for (let i = 0; i < ENEMY_C_SCATTER_COUNT; i++) {
                     const angle = (Math.PI * 2 / ENEMY_C_SCATTER_COUNT) * i + Math.random() * 0.2 - 0.1; // Even spread + slight randomness
                     enemyBullets.push({
                         x: centerX - ENEMY_BULLET_WIDTH / 2, y: centerY, width: ENEMY_BULLET_WIDTH, height: ENEMY_BULLET_HEIGHT,
                         color: 'red', speed: ENEMY_BULLET_SPEED * 0.8, // Boss bullets slightly slower
                         dx: Math.cos(angle) * (ENEMY_BULLET_SPEED * 0.8),
                         dy: Math.sin(angle) * (ENEMY_BULLET_SPEED * 0.8)
                     });
                 }
                 enemy.lastShotTime = currentTime;
            }
        }

        // --- Update Functions ---
        function updatePlayerBullets(dt) {
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const bullet = playerBullets[i];
                if (bullet.dx !== undefined) { // Scatter shot bullets
                    bullet.x += bullet.dx;
                    bullet.y += bullet.dy;
                } else { // Normal bullets
                    bullet.y -= bullet.speed;
                }

                // Check boundaries
                if (bullet.y + bullet.height < 0 || bullet.y > canvasHeight || bullet.x + bullet.width < 0 || bullet.x > canvasWidth) {
                    playerBullets.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (checkCollision(bullet, enemy)) {
                        enemy.health--;
                        playerBullets.splice(i, 1); // Remove bullet

                        if (enemy.health <= 0) {
                            score += enemy.scoreValue;
                             if (enemy.type === 'C') {
                                score += ENEMY_C_FINAL_SCORE; // Bonus for destroying boss
                                gameWon = true; // WIN!
                             }
                            enemies.splice(j, 1); // Remove enemy
                            if(enemy === bossInstance) bossInstance = null; // Clear boss ref
                        } else if (enemy.type === 'C') {
                             // Score for hitting boss even if not destroyed
                             score += enemy.scoreValue;
                        }
                         scoreDisplay.textContent = `分數: ${score}`;
                        break; // Bullet is gone, stop checking this bullet against other enemies
                    }
                }
            }
        }

        function updateEnemyBullets(dt) {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;

                 // Remove if off-screen
                 if (bullet.y < -bullet.height || bullet.y > canvasHeight || bullet.x < -bullet.width || bullet.x > canvasWidth) {
                     enemyBullets.splice(i, 1);
                     continue;
                 }

                // Check collision with player
                if (checkCollision(bullet, player)) {
                    enemyBullets.splice(i, 1);
                    gameOver = true; // LOSE!
                    return; // No need to check further this frame
                }
            }
        }

        function updateEnemies(dt) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Boss movement (move to target Y then hover slightly)
                 if(enemy.type === 'C') {
                     if(enemy.y < enemy.targetY) {
                         enemy.y += enemy.speed * (dt/16); // Move towards target Y
                     } else {
                          // Simple horizontal hover (can be made more complex)
                          enemy.x += Math.sin(performance.now() / 500) * 0.5;
                     }
                 } else {
                    enemy.y += enemy.speed * (dt/16); // Normal downward movement
                 }


                // Check if enemy reached bottom
                if (enemy.y > canvasHeight) {
                    enemies.splice(i, 1);
                     if(enemy === bossInstance) bossInstance = null;
                    gameOver = true; // LOSE! Enemy reached bottom
                    return;
                }

                // Check player collision
                if (checkCollision(player, enemy)) {
                    gameOver = true; // LOSE! Collided with player
                    return;
                }

                // Trigger enemy shooting
                if (enemy.type === 'B' || enemy.type === 'C') {
                    enemyShoot(enemy);
                }
            }
        }

         function updateScatterAmmo(dt) {
             if (playerScatterAmmo < SCATTER_AMMO_MAX) {
                 scatterAmmoRegenTimer += dt;
                 if (scatterAmmoRegenTimer >= SCATTER_AMMO_REGEN_TIME) {
                     playerScatterAmmo++;
                     scatterAmmoRegenTimer = 0; // Reset timer
                     updateAmmoDisplay();
                 }
             } else {
                 scatterAmmoRegenTimer = 0; // Reset timer if ammo is full
             }
         }

        // --- Draw Function ---
        function draw() {
            // Background
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Draw Player
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Draw Player Bullets
            playerBullets.forEach(bullet => {
                ctx.fillStyle = bullet.color || PLAYER_BULLET_COLOR;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });

            // Draw Enemies
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                 // Optional: Draw health bar for boss
                 if (enemy.type === 'C') {
                     const healthPercent = enemy.health / ENEMY_C_HEALTH_MAX;
                     const barWidth = enemy.width * 0.8;
                     const barX = enemy.x + (enemy.width - barWidth) / 2;
                     const barY = enemy.y - 10;
                     ctx.fillStyle = 'red';
                     ctx.fillRect(barX, barY, barWidth, 5);
                     ctx.fillStyle = 'lime';
                     ctx.fillRect(barX, barY, barWidth * healthPercent, 5);
                 }
            });

             // Draw Enemy Bullets
             enemyBullets.forEach(bullet => {
                 ctx.fillStyle = bullet.color;
                 // Draw circle bullets for enemies
                 ctx.beginPath();
                 ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, bullet.width/2, 0, Math.PI * 2);
                 ctx.fill();
                 //ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
             });
        }

        // --- Game Loop ---
        function gameLoop(currentTime) {
            const dt = currentTime - lastTime;
            lastTime = currentTime;

            if (gameOver || gameWon) {
                showEndScreen();
                return; // Stop the loop
            }

            // Check for Boss Trigger
            if (!bossActive && score >= BOSS_SCORE_THRESHOLD) {
                spawnBoss();
            }

            // Updates
            updatePlayerBullets(dt);
            if(gameOver || gameWon) { showEndScreen(); return; } // Re-check after updates

            updateEnemyBullets(dt);
             if(gameOver || gameWon) { showEndScreen(); return; }

            updateEnemies(dt);
             if(gameOver || gameWon) { showEndScreen(); return; }

            updateScatterAmmo(dt);

            // Drawing
            draw();

            // Request next frame
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // --- End Screen ---
        function showEndScreen() {
            // Clear intervals
            if (enemySpawnTimerId) clearInterval(enemySpawnTimerId);
            enemySpawnTimerId = null; // Ensure it's cleared

            // Display message based on win/loss
            if (gameWon) {
                uiTitle.textContent = "勝利!";
                uiMessage.textContent = `恭喜! 你擊敗了魔王! 最終分數: ${score}`;
            } else { // gameOver
                uiTitle.textContent = "遊戲結束";
                uiMessage.textContent = `最終分數: ${score}`;
            }
            restartButton.textContent = "重新開始"; // Ensure button text is correct
            uiLayer.classList.add('visible');
        }

        // --- Event Handlers ---
        function handleTouchStart(event) {
            if (gameOver || gameWon || event.touches.length !== 1) {
                touchStartX = null; playerStartX = null; return;
            }
            touchStartX = event.touches[0].clientX;
            playerStartX = player.x;
        }
        function handleTouchMove(event) {
            if (touchStartX === null || gameOver || gameWon) return;
            event.preventDefault(); // Crucial for mobile scrolling prevention
            if (event.touches.length === 1) {
                const touchCurrentX = event.touches[0].clientX;
                const touchDeltaX = touchCurrentX - touchStartX;
                player.x = playerStartX + touchDeltaX;
                // Clamp player position
                player.x = Math.max(0, Math.min(canvasWidth - player.width, player.x));
            }
        }
        function handleTouchEnd(event) {
            touchStartX = null; playerStartX = null;
        }
        function handleScatterShotClick() {
             if(!gameOver && !gameWon){
                playerShootScatter();
             }
        }

        // --- Initialization ---
        window.addEventListener('resize', () => {
             const wasGameOver = gameOver || gameWon; // Check state before resize
             resizeCanvas();
             // If game was over, keep showing end screen, otherwise reposition player
             if (!wasGameOver && player) {
                 player.x = canvasWidth / 2 - player.width / 2;
                 player.y = canvasHeight - player.height - 30;
             } else if (wasGameOver) {
                 // Optional: Redraw end screen if needed after resize
                 // showEndScreen();
             }
        });

        // Touch Events for Player Movement
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('touchcancel', handleTouchEnd);

        // Click/Touch Event for Scatter Shot Button
        scatterShotButton.addEventListener('click', handleScatterShotClick);
        scatterShotButton.addEventListener('touchstart', (e) => { // Prevent triggering move and click
             e.preventDefault(); // Stop potential double actions
             handleScatterShotClick();
        }, { passive: false });


        // Restart Button
        restartButton.addEventListener('click', () => {
             resizeCanvas(); // Ensure canvas is correct size before starting
             initGame();
        });

        // Initial Load
        resizeCanvas();
        uiTitle.textContent = "縱向射擊";
        uiMessage.textContent = "左右滑動閃避，點擊按鈕發射散彈。準備好了嗎？";
        restartButton.textContent = "開始遊戲";
        uiLayer.classList.add('visible');
        updateAmmoDisplay(); // Show initial ammo state (likely 0/3 or 3/3 depending on initGame)

    </script>
</body>
</html>
